def binomial_coefficient(n, k): 
    # Create a 2D array `C` with (n + 1) rows and (k + 1) columns, initialized with zeros
    C = [[0 for _ in range(k + 1)] for _ in range(n + 1)]
    
    # Start filling up the array using the formula for binomial coefficients
    for i in range(n + 1):
        # For each row `i`, only calculate up to the minimum of `i` and `k`
        for j in range(min(i, k) + 1):
            # Base case: if j is 0 or equal to i, set C[i][j] to 1
            if j == 0 or j == i:
                C[i][j] = 1
            # Use the recursive relation to calculate C[i][j]: C[i][j] = C[i-1][j-1] + C[i-1][j]
            else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j]

    # Return the final result, C[n][k], which is the binomial coefficient "n choose k"
    return C[n][k]

# Main function to handle user input and display the result
def main():
    # Get the values of n and k from the user
    n = int(input("Enter n (total elements): "))
    k = int(input("Enter k (elements to choose): "))
    
    # Check if the input values are valid, ensuring 0 <= k <= n
    if k > n or n < 0 or k < 0:
        print("Invalid input: Ensure that 0 <= k <= n.")
        return
    
    # Call the binomial_coefficient function to get the result for the given n and k
    result = binomial_coefficient(n, k)
    
    # Output the computed binomial coefficient
    print(f"The binomial coefficient C({n}, {k}) is: {result}")

# Run the main function to start the program
main()

# Sample Output:
# Enter n (total elements): 5
# Enter k (elements to choose): 2
# The binomial coefficient C(5, 2) is: 10

### Binomial Coefficient Calculation Using Dynamic Programming

**Problem Overview:**
The binomial coefficient, often written as \( C(n, k) \), represents the number of ways to choose \( k \) items from \( n \) items without regard to order. It’s commonly known as “n choose k” and is a key concept in combinatorics.

**Formula:**
The binomial coefficient \( C(n, k) \) is calculated using the formula:
\[ C(n, k) = C(n-1, k-1) + C(n-1, k) \]
With two important base cases:
1. \( C(n, 0) = 1 \): There's only one way to choose 0 items from n items.
2. \( C(n, n) = 1 \): There's only one way to choose all items from n items.

**Why Dynamic Programming?**
Dynamic programming (DP) helps by storing previously computed values to avoid redundant calculations. Instead of recalculating \( C(n, k) \) repeatedly, we use a table to keep track of all computed values, saving time and making the process more efficient.

### Steps in the DP Approach

1. **Create a 2D Table (Array):**
   - We create a 2D table `C` where `C[i][j]` will store the value of \( C(i, j) \).
   - The table will have \( (n+1) \) rows and \( (k+1) \) columns.

2. **Initialize the Base Cases:**
   - For each row \( i \):
     - Set \( C(i, 0) = 1 \) since there’s only one way to choose 0 items from i items.
     - Set \( C(i, i) = 1 \) since there’s only one way to choose all items from i items.

3. **Fill the Table Using the Formula:**
   - For each \( i \) from 1 to \( n \):
     - For each \( j \) from 1 to \( \min(i, k) \):
       - Use the formula: \( C(i, j) = C(i-1, j-1) + C(i-1, j) \) to calculate each value.

4. **Result:**
   - After filling in the table, \( C(n, k) \) will hold the result, which is the total number of ways to choose \( k \) items from \( n \).

### Example Walkthrough:

Suppose \( n = 5 \) and \( k = 2 \).
1. **Initialize the Table:** Start with a table of zeros.
2. **Apply Base Cases:** Fill in all cells where \( j = 0 \) and \( j = i \) with 1.
3. **Fill the Table with the Formula:** Use the formula \( C(i, j) = C(i-1, j-1) + C(i-1, j) \) for each cell.

By the end, the table will contain all values of \( C(i, j) \) for \( i = 0 \) to \( n \) and \( j = 0 \) to \( k \). The answer \( C(n, k) \) can then be found at `C[n][k]`.

This DP approach provides a clear, efficient way to compute binomial coefficients without recalculating overlapping subproblems.
